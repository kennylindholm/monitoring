#!/bin/bash
{% raw %}
# Monitoring Services Health Check Script
# This script performs automated health checks for monitoring services
# Generated by Ansible - Do not edit manually

set -euo pipefail

# Configuration
{% endraw %}
MONITORING_DIR="{{ monitoring_base_dir }}"
LOG_FILE="${MONITORING_DIR}/logs/health-check.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
{% raw %}
CHECK_TIMEOUT=10
ALERT_THRESHOLD=3  # Number of consecutive failures before alerting
{% endraw %}

# Services to check
declare -A SERVICES=(
{% for service in monitoring_services | default([]) %}
    ["{{ service.name }}"]="{{ service.port }}:{{ service.path | default('/') }}"
{% endfor %}
)

{% raw %}
# Alert configuration
{% endraw %}
ALERT_EMAIL="{{ monitoring_notification_email | default('') }}"
ALERT_SLACK_WEBHOOK="{{ monitoring_notification_slack_webhook | default('') }}"

{% raw %}
# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# State file for tracking failures
{% endraw %}
STATE_FILE="${MONITORING_DIR}/logs/.health-check-state"

{% raw %}
# Logging function
log() {
    echo "[${TIMESTAMP}] $1" | tee -a "$LOG_FILE"
}

# Initialize state file
init_state_file() {
    if [[ ! -f "$STATE_FILE" ]]; then
        for service in "${!SERVICES[@]}"; do
            echo "${service}:0" >> "$STATE_FILE"
        done
    fi
}

# Get failure count for service
get_failure_count() {
    local service="$1"
    grep "^${service}:" "$STATE_FILE" 2>/dev/null | cut -d: -f2 || echo "0"
}

# Set failure count for service
set_failure_count() {
    local service="$1"
    local count="$2"

    if grep -q "^${service}:" "$STATE_FILE" 2>/dev/null; then
        sed -i "s/^${service}:.*/${service}:${count}/" "$STATE_FILE"
    else
        echo "${service}:${count}" >> "$STATE_FILE"
    fi
}

# Check if service is running
is_service_running() {
    local service="$1"
    systemctl is-active --quiet "$service" 2>/dev/null
}

# Check HTTP endpoint
check_endpoint() {
    local url="$1"
    local timeout="$2"

    if command -v curl >/dev/null 2>&1; then
        curl -s --max-time "$timeout" --fail "$url" >/dev/null 2>&1
    elif command -v wget >/dev/null 2>&1; then
        wget -q --timeout="$timeout" --tries=1 --spider "$url" >/dev/null 2>&1
    else
        return 1
    fi
}

# Check individual service health
check_service_health() {
    local service="$1"
    local port_path="${SERVICES[$service]}"
    local port="${port_path%:*}"
    local path="${port_path#*:}"
    local url="http://localhost:${port}${path}"

    local current_failures
    current_failures=$(get_failure_count "$service")

    if ! is_service_running "$service"; then
        log "ERROR: Service $service is not running"
        set_failure_count "$service" $((current_failures + 1))
        return 1
    fi

    if ! check_endpoint "$url" "$CHECK_TIMEOUT"; then
        log "ERROR: Service $service endpoint $url is not responding"
        set_failure_count "$service" $((current_failures + 1))
        return 1
    fi

    # Service is healthy, reset failure count
    if [[ $current_failures -gt 0 ]]; then
        log "INFO: Service $service recovered"
        set_failure_count "$service" 0
    fi

    return 0
}

# Send email alert
send_email_alert() {
    local subject="$1"
    local message="$2"

    if [[ -n "$ALERT_EMAIL" ]] && command -v mail >/dev/null 2>&1; then
        echo -e "$message" | mail -s "$subject" "$ALERT_EMAIL"
        log "INFO: Email alert sent to $ALERT_EMAIL"
    fi
}

# Send Slack alert
send_slack_alert() {
    local message="$1"

    if [[ -n "$ALERT_SLACK_WEBHOOK" ]] && command -v curl >/dev/null 2>&1; then
        local payload="{\"text\":\"$message\"}"
        if curl -X POST -H 'Content-type: application/json' --data "$payload" "$ALERT_SLACK_WEBHOOK" >/dev/null 2>&1; then
            log "INFO: Slack alert sent"
        else
            log "ERROR: Failed to send Slack alert"
        fi
    fi
}

# Send alert for failed service
send_service_alert() {
    local service="$1"
    local failures="$2"

    local subject="[ALERT] Monitoring Service $service Failed"
    local message="Service: $service
Hostname: $(hostname -f)
Timestamp: $TIMESTAMP
Consecutive Failures: $failures
Status: $(systemctl is-active "$service" 2>/dev/null || echo "inactive")

Please check the service status:
sudo systemctl status $service
sudo journalctl -u $service --no-pager --lines=20"

    send_email_alert "$subject" "$message"
    send_slack_alert "ðŸš¨ Monitoring service *$service* has failed $failures times on $(hostname -f)"
}

# Send recovery alert
send_recovery_alert() {
    local service="$1"

    local subject="[RECOVERY] Monitoring Service $service Recovered"
    local message="Service: $service
Hostname: $(hostname -f)
Timestamp: $TIMESTAMP
Status: Recovered

The service is now responding normally."

    send_email_alert "$subject" "$message"
    send_slack_alert "âœ… Monitoring service *$service* has recovered on $(hostname -f)"
}

# Perform system health checks
check_system_health() {
    local issues=0

    # Check disk space
    local disk_usage
    disk_usage=$(df -h "$MONITORING_DIR" 2>/dev/null | awk 'NR==2{print $5}' | tr -d '%' || echo "0")
    if [[ $disk_usage -gt 90 ]]; then
        log "WARNING: Disk usage is ${disk_usage}% for monitoring directory"
        ((issues++))
    fi

    # Check memory usage
    local memory_usage
    memory_usage=$(free | awk 'NR==2{printf "%.0f", $3/$2*100}')
    if [[ $memory_usage -gt 95 ]]; then
        log "WARNING: Memory usage is ${memory_usage}%"
        ((issues++))
    fi

    # Check load average
    local load_avg
    load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $1}' | tr -d ' ')
    local cpu_cores
    cpu_cores=$(nproc)
    local load_threshold=$((cpu_cores * 2))

    if (( $(echo "$load_avg > $load_threshold" | bc -l 2>/dev/null || echo "0") )); then
        log "WARNING: Load average $load_avg is high (threshold: $load_threshold)"
        ((issues++))
    fi

    return $issues
}

# Generate health report
generate_health_report() {
    local healthy_services=0
    local failed_services=0
    local total_services=${#SERVICES[@]}

    for service in "${!SERVICES[@]}"; do
        if check_service_health "$service"; then
            ((healthy_services++))
        else
            ((failed_services++))
        fi
    done

    local health_percentage=$((healthy_services * 100 / total_services))

    log "Health Check Summary: ${healthy_services}/${total_services} services healthy (${health_percentage}%)"

    # Check for services that need alerting
    for service in "${!SERVICES[@]}"; do
        local failures
        failures=$(get_failure_count "$service")

        if [[ $failures -ge $ALERT_THRESHOLD ]]; then
            log "ALERT: Service $service has failed $failures consecutive times"
            send_service_alert "$service" "$failures"
        fi
    done

    return $failed_services
}

# Cleanup old logs
cleanup_logs() {
    # Keep only last 1000 lines of health check log
    if [[ -f "$LOG_FILE" ]]; then
        tail -n 1000 "$LOG_FILE" > "${LOG_FILE}.tmp" && mv "${LOG_FILE}.tmp" "$LOG_FILE"
    fi
}

# Main function
main() {
    # Create necessary directories
    mkdir -p "$(dirname "$LOG_FILE")"
    mkdir -p "$(dirname "$STATE_FILE")"

    # Initialize state tracking
    init_state_file

    log "Starting health check for monitoring services"

    # Perform health checks
    local failed_services=0
    if ! generate_health_report; then
        failed_services=$?
    fi

    # Check system health
    local system_issues=0
    if ! check_system_health; then
        system_issues=$?
    fi

    # Cleanup
    cleanup_logs

    # Exit with appropriate code
    if [[ $failed_services -eq 0 && $system_issues -eq 0 ]]; then
        log "Health check completed successfully"
        exit 0
    else
        log "Health check completed with issues: $failed_services failed services, $system_issues system issues"
        exit 1
    fi
}

# Handle command line arguments
case "${1:-}" in
    --quiet|-q)
        # Quiet mode - suppress output except errors
        exec 1>/dev/null
        main
        ;;
    --test|-t)
        # Test mode - check configuration
        echo "Health check configuration test:"
        echo "Services configured: ${#SERVICES[@]}"
        for service in "${!SERVICES[@]}"; do
            echo "  - $service: ${SERVICES[$service]}"
        done
        echo "Alert email: ${ALERT_EMAIL:-"Not configured"}"
        echo "Alert Slack: ${ALERT_SLACK_WEBHOOK:+"Configured"}"
        echo "State file: $STATE_FILE"
        echo "Log file: $LOG_FILE"
        exit 0
        ;;
    --reset|-r)
        # Reset failure counts
        echo "Resetting failure counts..."
        rm -f "$STATE_FILE"
        init_state_file
        echo "Failure counts reset"
        exit 0
        ;;
    --help|-h)
        echo "Usage: $0 [OPTIONS]"
        echo "Options:"
        echo "  --quiet, -q    Run in quiet mode"
        echo "  --test, -t     Test configuration"
        echo "  --reset, -r    Reset failure counts"
        echo "  --help, -h     Show this help"
        exit 0
        ;;
    *)
        main "$@"
        ;;
esac
{% endraw %}
